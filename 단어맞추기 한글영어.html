<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>철자 한 번 가로질러 사라지기 — 단어 선택/저장 로직 패치</title>
<style>
  :root{ --bg:#fff; --ink:#0f172a; --border:#e5e7eb; }
  *{ box-sizing:border-box }
  html,body{ height:100vh }
  body{
    margin:0;background:var(--bg);color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",Apple SD Gothic Neo,sans-serif;
    display:grid;grid-template-rows:auto 1fr;min-height:100vh
  }
  header{
    border-bottom:1px solid var(--border);background:#fafafa;
    padding:12px 16px;display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap
  }
  header h1{font-size:16px;margin:0;font-weight:800}
  .panel{width:100%;display:grid;gap:12px;grid-template-columns:1fr auto auto;align-items:start}
  .inputs{grid-column:1/2;display:grid;gap:8px;grid-template-columns:repeat(auto-fill,minmax(160px,1fr))}
  .wordInput{padding:10px 12px;border:1px solid #d1d5db;border-radius:10px;background:#fff}

  .btn{appearance:none;border:1px solid #cbd5e1;background:#fff;color:#111827;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:800}
  .btn.primary{background:#111827;color:#fff;border-color:#111827}
  .btn.ghost{background:#fff}
  .btn:active{transform:translateY(1px)}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .hint{font-size:12px;color:#6b7280}

  .stage{position:relative;width:100%;height:100%;min-height:70vh;overflow:hidden;background:#fff}
  .letter{
    position:absolute;white-space:pre;font-weight:900;user-select:none;pointer-events:none;
    text-shadow:0 1px 0 rgba(0,0,0,0.04);will-change:transform;z-index:1
  }
  .topbar{
    position:absolute;left:0;right:0;top:0;display:flex;justify-content:center;padding:10px;z-index:2
  }
  .toolbar{
    display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    background:rgba(255,255,255,.92);border:1px solid var(--border);border-radius:999px;padding:8px 12px;
    box-shadow:0 6px 22px rgba(0,0,0,.06)
  }
  .control{display:flex;gap:8px;align-items:center}
  .control label{font-size:12px;opacity:.85}
  input[type="range"]{width:160px}
  input[type="number"]{width:80px}
  .hidden{display:none !important}

  /* 센터 정답 카드 */
  .answer-card{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    pointer-events:none; z-index:3;
  }
  .answer-card .card{
    background:rgba(255,255,255,.95);
    border:1px solid var(--border);
    border-radius:16px;
    padding:20px 28px;
    box-shadow:0 12px 36px rgba(0,0,0,.12);
    font-size:28px;font-weight:900;letter-spacing:.3px
  }
</style>
</head>
<body>
  <!-- 입력 화면 -->
  <header id="setupHeader">
    <h1>철자 한 번 가로질러 사라지기</h1>
    <div class="panel">
      <div class="inputs" id="inputs"></div>

      <!-- 입력창 추가/삭제 -->
      <div class="btnrow" style="grid-column: 1 / -1;">
        <button class="btn" id="addInputBtn">+ 입력창 추가</button>
        <button class="btn ghost" id="removeInputBtn">– 마지막 입력창 삭제</button>
        <span class="hint">빈 칸은 무시됩니다. 예: apple, banana, 한글도 가능</span>
      </div>

      <!-- 초기화 + 자모 분해(입력 화면) -->
      <div class="btnrow" style="grid-column: 1 / -1; justify-content:space-between;">
        <div class="control">
          <label for="decompose">한글 자모 분해</label>
          <input id="decompose" type="checkbox" />
        </div>
        <div class="btnrow">
          <button class="btn ghost" id="clearSaveBtn" title="저장 삭제">초기화</button>
          <button class="btn primary" id="startBtn">시작</button>
        </div>
      </div>
    </div>
  </header>

  <!-- 문제 화면 -->
  <div class="stage" id="stage" aria-label="게임 무대">
    <!-- 툴바 -->
    <div class="topbar hidden" id="gameBar">
      <div class="toolbar">
        <button class="btn" id="homeBtn">처음으로</button>
        <button class="btn" id="revealBtn">정답확인</button>
        <button class="btn primary" id="playBtn">시작(재생)</button>
        <button class="btn" id="nextBtn">다음 문제</button>

        <div class="control">
          <label for="fontSize">글자(px)</label>
          <input id="fontSize" type="number" min="12" step="2" value="42" />
        </div>
        <div class="control">
          <label for="speedScale">속도(%)</label>
          <!-- 100 → 10 으로 낮춰가며 조절 (기본 속도는 3배로 상향) -->
          <input id="speedScale" type="range" min="10" max="100" value="100" />
          <span id="speedLabel">100%</span>
        </div>
        <div class="control">
          <label for="autosave">자동 저장</label>
          <input id="autosave" type="checkbox" checked />
        </div>
      </div>
    </div>

    <!-- 센터 정답 카드 (시작/다음 누를 때까지 유지) -->
    <div class="answer-card hidden" id="answerCard" aria-live="polite">
      <div class="card" id="answerText">정답</div>
    </div>
  </div>

<script>
(() => {
  // ---------- DOM ----------
  const inputsWrap = document.getElementById('inputs');
  const addInputBtn = document.getElementById('addInputBtn');
  const removeInputBtn = document.getElementById('removeInputBtn');
  const startBtn = document.getElementById('startBtn');
  const setupHeader = document.getElementById('setupHeader');

  const stage = document.getElementById('stage');
  const gameBar = document.getElementById('gameBar');
  const homeBtn = document.getElementById('homeBtn');
  const revealBtn = document.getElementById('revealBtn');
  const nextBtn = document.getElementById('nextBtn');
  const playBtn = document.getElementById('playBtn');

  const fontSizeInput = document.getElementById('fontSize');
  const speedScaleRange = document.getElementById('speedScale');
  const speedLabel = document.getElementById('speedLabel');

  // 자모 분해(입력 화면)
  const decomposeChk = document.getElementById('decompose');

  // 자동저장
  const autosave = document.getElementById('autosave');
  const clearSaveBtn = document.getElementById('clearSaveBtn');
  const LS_KEY = 'vibeSpeller:v3'; // 기존 키 유지(단, currentWord는 더 이상 저장 안 함)

  // 정답 카드
  const answerCard = document.getElementById('answerCard');
  const answerText = document.getElementById('answerText');

  // ---------- State ----------
  let currentWord = "";                 // ★ 더 이상 저장/복원하지 않음
  let decomposeInRound = false;         // 시작 시점의 자모 분해 설정만 사용

  // 초기 입력창(기본 3개)
  const seed = ["apple","banana","한글"];
  for (let i=0;i<3;i++) addWordInput(seed[i] || "");

  // ---------- Helpers ----------
  function addWordInput(value=""){
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = '단어 입력';
    input.className = 'wordInput';
    input.value = value;
    inputsWrap.appendChild(input);
  }
  function removeLastWordInput(){
    const kids = inputsWrap.querySelectorAll('.wordInput');
    if (kids.length>1) inputsWrap.lastElementChild.remove();
  }
  addInputBtn.addEventListener('click', ()=> { addWordInput(""); saveState(); });
  removeInputBtn.addEventListener('click', ()=> { removeLastWordInput(); saveState(); });

  speedScaleRange.addEventListener('input', ()=> {
    speedLabel.textContent = `${speedScaleRange.value}%`;
    saveState();
  });
  fontSizeInput.addEventListener('input', saveState);
  decomposeChk.addEventListener('change', saveState);

  function getWords(){
    return Array.from(inputsWrap.querySelectorAll('.wordInput'))
      .map(i => (i.value || "").trim())
      .filter(Boolean);
  }
  function pickRandomWord(){
    const w = getWords();
    if (!w.length) return "";
    return w[Math.floor(Math.random()*w.length)];
  }
  function randomColorDark(){
    const h = Math.floor(Math.random()*360);
    const s = 65 + Math.random()*25;   // 65~90
    const l = 28 + Math.random()*12;   // 28~40 (진한 계열)
    return `hsl(${h} ${s}% ${l}%)`;
  }
  function clearStage(){
    stage.querySelectorAll('.letter').forEach(n => n.remove());
  }

  // ---------- Autosave ----------
  function restoreState() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;

      const s = JSON.parse(raw);

      if (Array.isArray(s.words) && s.words.length) {
        inputsWrap.innerHTML = '';
        s.words.forEach(w => addWordInput(w));
      }
      if (s.fontSize) fontSizeInput.value = s.fontSize;
      if (s.speedScale) {
        speedScaleRange.value = s.speedScale;
        speedLabel.textContent = `${s.speedScale}%`;
      }
      if (typeof s.decompose === 'boolean') decomposeChk.checked = s.decompose;
      if (typeof s.autosave === 'boolean') autosave.checked = s.autosave;

      // ★ currentWord는 복원하지 않음 (이전 버전 저장값도 무시)
    } catch (e) {/* 무시 */}
  }
  function saveState() {
    if (!autosave.checked) return;
    const payload = {
      words: getWords(),
      fontSize: Number(fontSizeInput.value || 42),
      speedScale: Number(speedScaleRange.value || 100),
      decompose: !!decomposeChk.checked,
      autosave: autosave.checked
      // ★ currentWord 저장 안 함
    };
    try { localStorage.setItem(LS_KEY, JSON.stringify(payload)); } catch (e) {}
  }
  function ensureAtLeastOneInput(){
    if (!inputsWrap.querySelector('.wordInput')) addWordInput('');
  }

  // 저장 삭제(초기화) + 현재 단어 리셋
  clearSaveBtn.addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    currentWord = "";                   // ★ 리셋
    alert('저장된 단어/설정을 삭제했습니다.');
  });
  autosave.addEventListener('change', saveState);
  inputsWrap.addEventListener('input', (e) => {
    if (e.target.classList.contains('wordInput')) saveState();
  });

  // ---------- Hangul Jamo Decomposition ----------
  const LCompat = ['ㄱ','ㄲ','ㄴ','ㄷ','ㄸ','ㄹ','ㅁ','ㅂ','ㅃ','ㅅ','ㅆ','ㅇ','ㅈ','ㅉ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
  const VCompat = ['ㅏ','ㅐ','ㅑ','ㅒ','ㅓ','ㅔ','ㅕ','ㅖ','ㅗ','ㅘ','ㅙ','ㅚ','ㅛ','ㅜ','ㅝ','ㅞ','ㅟ','ㅠ','ㅡ','ㅢ','ㅣ'];
  const TCompat = ['','ㄱ','ㄲ','ㄳ','ㄴ','ㄵ','ㄶ','ㄷ','ㄹ','ㄺ','ㄻ','ㄼ','ㄽ','ㄾ','ㄿ','ㅀ','ㅁ','ㅂ','ㅄ','ㅅ','ㅆ','ㅇ','ㅈ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
  const TDecomp = { 'ㄳ':['ㄱ','ㅅ'], 'ㄵ':['ㄴ','ㅈ'], 'ㄶ':['ㄴ','ㅎ'], 'ㄺ':['ㄹ','ㄱ'], 'ㄻ':['ㄹ','ㅁ'], 'ㄼ':['ㄹ','ㅂ'], 'ㄽ':['ㄹ','ㅅ'], 'ㄾ':['ㄹ','ㅌ'], 'ㄿ':['ㄹ','ㅍ'], 'ㅀ':['ㄹ','ㅎ'], 'ㅄ':['ㅂ','ㅅ'] };

  const SBase=0xAC00, LBase=0x1100, VBase=0x1161, TBase=0x11A7;
  const LCount=19, VCount=21, TCount=28, NCount=VCount*TCount, SCount=LCount*NCount;

  const reHangul = /[\uAC00-\uD7A3]/;
  const reIgnore = /[\s\p{P}\p{S}]/u; // 공백/문장부호/기호 무시

  function decomposeSyllable(ch){
    const code = ch.codePointAt(0);
    const SIndex = code - SBase;
    if (SIndex < 0 || SIndex >= SCount) return [ch];

    const LIndex = Math.floor(SIndex / NCount);
    const VIndex = Math.floor((SIndex % NCount) / TCount);
    const TIndex = SIndex % TCount;

    const Lc = LCompat[LIndex];
    const Vc = VCompat[VIndex];
    let out = [Lc, Vc];
    if (TIndex > 0) {
      const Tc = TCompat[TIndex];
      if (TDecomp[Tc]) out = out.concat(TDecomp[Tc]);
      else out.push(Tc);
    }
    return out;
  }

  function toUnits(word, useDecompose){
    const units = [];
    for (const ch of Array.from(word)){
      if (reIgnore.test(ch)) continue; // 공백/기호 무시
      if (useDecompose && reHangul.test(ch)) {
        units.push(...decomposeSyllable(ch));
      } else {
        units.push(ch);
      }
    }
    return units;
  }

  // ---------- Answer Card ----------
  function showAnswerCard(text){
    answerText.textContent = `정답: ${text}`;
    answerCard.classList.remove('hidden');
  }
  function hideAnswerCard(){
    answerCard.classList.add('hidden');
  }

  // ---------- Flow ----------
  restoreState();
  ensureAtLeastOneInput();
  speedLabel.textContent = `${speedScaleRange.value}%`;

  // 시작: ★ 무조건 새 단어 뽑기 + currentWord 리셋 효과 포함
  startBtn.addEventListener('click', ()=>{
    const w = getWords();
    if (!w.length) { alert("단어를 최소 1개 입력해주세요."); return; }

    currentWord = pickRandomWord();     // ★ 항상 새로 선택
    decomposeInRound = !!decomposeChk.checked;

    setupHeader.classList.add('hidden');
    gameBar.classList.remove('hidden');

    hideAnswerCard();
    playOnce(); // 첫 재생
    saveState();
  });

  // 같은 단어로 재생
  playBtn.addEventListener('click', ()=> { hideAnswerCard(); playOnce(); saveState(); });

  // 다음 문제(랜덤 새 단어) — 원래대로 새로 뽑음
  nextBtn.addEventListener('click', ()=>{
    const w = getWords();
    if (!w.length) { alert("단어 입력이 비어 있습니다."); return; }

    currentWord = pickRandomWord();     // ★ 항상 새로 선택
    hideAnswerCard();
    playOnce();
    saveState();
  });

  // 정답확인 → 센터 카드로 표시(유지)
  revealBtn.addEventListener('click', ()=>{
    showAnswerCard(currentWord || "—");
  });

  // 처음으로: 무대 비우고 입력 화면 복귀 + ★ 현재 단어 리셋
  homeBtn.addEventListener('click', ()=>{
    clearStage();
    hideAnswerCard();
    currentWord = "";                   // ★ 리셋
    gameBar.classList.add('hidden');
    setupHeader.classList.remove('hidden');
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });

  // ---------- Animation (CSS 트랜지션, 1회 통과) ----------
  function playOnce(){
    if (!currentWord) {
      // 안전 가드: 혹시라도 비어 있으면 즉시 새로 뽑기
      currentWord = pickRandomWord();
      if (!currentWord) { alert("단어가 없습니다."); return; }
    }

    clearStage();

    // 무대 크기 (0 가드)
    let rect = stage.getBoundingClientRect();
    let width = rect.width || window.innerWidth || 800;
    let height = rect.height || Math.max(window.innerHeight * 0.7, 400);

    // 툴바 회피: gameBar의 bottom을 기준으로 안전 상단선 계산
    let safeTop = 14;
    if (!gameBar.classList.contains('hidden')) {
      const tool = gameBar.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      safeTop = Math.max(14, (tool.bottom - stageRect.top) + 8);
      if (safeTop > height - 60) safeTop = Math.max(14, height * 0.2);
    }
    const bottomMargin = 14;

    const units = toUnits(currentWord, decomposeInRound);
    const fs = Math.max(12, Number(fontSizeInput.value || 42));
    const scale = (Number(speedScaleRange.value || 100) / 100); // 1.0~0.1 (느려짐)
    const off = 24;

    units.forEach((ch) => {
      const el = document.createElement('div');
      el.className = 'letter';
      el.textContent = ch;
      el.style.fontSize = `${fs}px`;
      el.style.color = randomColorDark();
      el.style.transition = 'none';
      stage.appendChild(el);

      const w = el.getBoundingClientRect().width || fs * 0.6;
      const h = el.getBoundingClientRect().height || fs * 1.0;

      // 수직 위치: 툴바 아래부터 스폰
      let yMin = Math.min(safeTop, Math.max(0, height - h - bottomMargin));
      let yMax = Math.max(safeTop, height - h - bottomMargin);
      if (yMax < yMin) { yMin = 10; yMax = Math.max(10, height - h - 10); }
      const y = yMin + Math.random() * Math.max(1, (yMax - yMin));

      // 방향 무작위: 좌→우(1) / 우→좌(-1)
      const dir = Math.random() < 0.5 ? 1 : -1;

      const startX = (dir === 1) ? (-w - off) : (width + off);
      const endX   = (dir === 1) ? (width + off) : (-w - off);

      // 거리와 속도 → 트랜지션 시간 계산
      const distance = Math.abs(endX - startX);
      const base = (160 + Math.random()*220) * 3;   // 기본 속도 3배
      const jitter = 0.85 + Math.random()*0.5;      // ×0.85~1.35
      const pxPerSec = base * jitter * scale;       // scale: 1.0~0.1 (느려짐)
      const durationSec = Math.max(0.6, distance / Math.max(40, pxPerSec)); // 과도한 저속 방지

      // 약간의 등장 지연(스태거)
      const delayMs = Math.random()*450; // 0~450ms

      // 초기 위치 배치
      el.style.transform = `translate(${startX}px, ${y}px)`;

      // 다음 프레임에 트랜지션 걸고 종착지로 이동
      requestAnimationFrame(() => {
        setTimeout(() => {
          el.style.transition = `transform ${durationSec}s linear`;
          el.style.transform = `translate(${endX}px, ${y}px)`;
        }, delayMs);
      });

      // 이동 종료되면 제거
      el.addEventListener('transitionend', () => el.remove(), { once:true });
    });

    // 라벨 보정
    speedLabel.textContent = `${speedScaleRange.value}%`;
  }
})();
</script>
</body>
</html>
